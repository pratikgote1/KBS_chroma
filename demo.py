from fastapi import FastAPI, HTTPException , Query
from pydantic import BaseModel
from typing import List, Dict
import chromadb
from app.services.embedding import get_embedding

app = FastAPI()

chroma_client = chromadb.PersistentClient(path="./chroma_db")
collection = chroma_client.get_or_create_collection(name="my_knowledge_base")


# Define the Knowledge and KnowledgeSet model
class Knowledge(BaseModel):
    id: str
    name_of_knowledge: str
    text: str
    vector: List[float] = None
    
class KnowledgeSet(BaseModel):
    id: str
    name: str
    description: str
    knowledge: List[Knowledge] = []
knowledge_sets: Dict[str, KnowledgeSet] = {}


@app.post("/knowledge_sets/")
def create_knowledge_set(knowledge_set: KnowledgeSet):
    if knowledge_set.id in knowledge_sets:
        raise HTTPException(status_code=400, detail="Knowledge Set already exists")
    knowledge_sets[knowledge_set.id] = knowledge_set
    chroma_client.create_collection(knowledge_set.name)
    return knowledge_set


@app.get("/knowledge_sets/{knowledge_set_id}")
def read_knowledge_set(knowledge_set_id: str):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    return knowledge_sets[knowledge_set_id]


@app.put("/knowledge_sets/{knowledge_set_id}")
def update_knowledge_set(knowledge_set_id: str, knowledge_set: KnowledgeSet):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    knowledge_sets[knowledge_set_id] = knowledge_set
    return knowledge_set

@app.delete("/knowledge_sets/{knowledge_set_id}")
def delete_knowledge_set(knowledge_set_id: str):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    del knowledge_sets[knowledge_set_id]
    chroma_client.delete_collection(knowledge_set_id)
    return {"detail": "Knowledge Set deleted"}

# Code Generated by Sidekick is for learning and experimentation purposes only.
@app.post("/knowledge_sets/{knowledge_set_id}/knowledge/")
def add_knowledge(knowledge_set_id: str, text: str = Query(...)):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    
    # Generate embedding for the text
    embedding = get_embedding(text)
    
    # Ensure the embedding is a list of lists of floats
    if hasattr(embedding, 'tolist'):
        embedding_list = embedding.tolist()
    else:
        embedding_list = embedding
    
    # Ensure the embedding_list is a list of lists
    if not isinstance(embedding_list[0], list):
        embedding_list = [embedding_list]
    
    # Add knowledge to the collection
    collection.add(
        ids=[knowledge_set_id + "_" + text[:10]],
        embeddings=embedding_list,
        metadatas=[{"knowledge_set": knowledge_set_id, "text": text}]
    )
    
    # Add knowledge to the in-memory storage
    knowledge = Knowledge(id=knowledge_set_id + "_" + text[:10], name_of_knowledge=text[:10], text=text, vector=embedding_list[0])
    knowledge_sets[knowledge_set_id].knowledge.append(knowledge)
    
    return {"message": "Knowledge added successfully"}


@app.get("/knowledge_sets/{knowledge_set_id}/knowledge/{knowledge_id}")
def read_knowledge(knowledge_set_id: str, knowledge_id: str):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    for knowledge in knowledge_sets[knowledge_set_id].knowledge:
        if knowledge.id == knowledge_id:
            return knowledge
    raise HTTPException(status_code=404, detail="Knowledge not found")

@app.put("/knowledge_sets/{knowledge_set_id}/knowledge/{knowledge_id}")
def update_knowledge(knowledge_set_id: str, knowledge_id: str, text: str):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    for i, k in enumerate(knowledge_sets[knowledge_set_id].knowledge):
        if k.id == knowledge_id:
            # Generate embedding for the text
            embedding = get_embedding(text)
            
            # Update knowledge in the collection
            collection.update(
                ids=[knowledge_id],
                embeddings=[embedding],
                metadatas=[{"knowledge_set": knowledge_set_id, "text": text}]
            )
            
            # Update knowledge in the in-memory storage
            knowledge_sets[knowledge_set_id].knowledge[i].text = text
            knowledge_sets[knowledge_set_id].knowledge[i].vector = embedding
            
            return {"message": "Knowledge updated successfully"}
    raise HTTPException(status_code=404, detail="Knowledge not found")

@app.delete("/knowledge_sets/{knowledge_set_id}/knowledge/{knowledge_id}")
def delete_knowledge(knowledge_set_id: str, knowledge_id: str):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    for i, k in enumerate(knowledge_sets[knowledge_set_id].knowledge):
        if k.id == knowledge_id:
            del knowledge_sets[knowledge_set_id].knowledge[i]
            
            # Delete knowledge from the collection
            collection.delete(ids=[knowledge_id])
            
            return {"message": "Knowledge deleted successfully"}
    raise HTTPException(status_code=404, detail="Knowledge not found")

# Basic Vector Search
@app.post("/knowledge_sets/{knowledge_set_id}/search/")
def search_knowledge(knowledge_set_id: str, query: str, top_k: int = 5):
    if knowledge_set_id not in knowledge_sets:
        raise HTTPException(status_code=404, detail="Knowledge Set not found")
    
    # Generate embedding for the query
    query_embedding = get_embedding(query)
    
    # Perform vector search using ChromaDB
    results = collection.query(query_embeddings=[query_embedding], n_results=top_k)
    
    return results["documents"][0]










# #######




@app.delete("/knowledge_sets/")
def delete_all_knowledge_sets():
    for knowledge_set_id in list(knowledge_sets.keys()):
        # Delete the collection from ChromaDB
        formatted_name = format_collection_name(knowledge_sets[knowledge_set_id].name)
        chroma_client.delete_collection(formatted_name)
        # Remove the knowledge set from in-memory storage
        del knowledge_sets[knowledge_set_id]
    return {"detail": "All knowledge sets and their records have been deleted"}



@app.delete("/collections/")
def delete_all_collections():
    existing_collections = chroma_client.list_collections()
    for collection_name in existing_collections:
        chroma_client.delete_collection(collection_name)
    return {"detail": "All collections have been deleted"}


# Run the application
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
